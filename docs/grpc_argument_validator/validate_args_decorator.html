<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>grpc_argument_validator.validate_args_decorator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grpc_argument_validator.validate_args_decorator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import functools
import itertools
from dataclasses import dataclass
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import List
from typing import Optional
from typing import Union

import grpc
from google.protobuf import any_pb2
from google.protobuf.descriptor import FieldDescriptor
from google.protobuf.message import Message
from google.rpc import code_pb2
from google.rpc import error_details_pb2
from google.rpc import status_pb2
from grpc_argument_validator import AbstractArgumentValidator
from grpc_argument_validator import ArgumentValidatorConfig
from grpc_argument_validator.argument_validators import NonDefaultValidator
from grpc_argument_validator.argument_validators import NonEmptyValidator
from grpc_argument_validator.argument_validators import UUIDBytesValidator
from grpc_argument_validator.fields import validate_field_names
from grpc_argument_validator.validation_context import ValidationContext
from grpc_status import rpc_status


@dataclass
class _FieldViolation:
    field_name: str
    reason: str


def _none_or_empty(x: Optional[List[Any]]):
    return x is None or len(x) == 0


def validate_args(
    has: Optional[List[str]] = None,
    uuids: Optional[List[str]] = None,
    non_default: Optional[List[str]] = None,
    non_empty: Optional[List[str]] = None,
    optional_uuids: Optional[List[str]] = None,
    optional_non_empty: Optional[List[str]] = None,
    optional_non_default: Optional[List[str]] = None,
    validators: Optional[Dict[str, AbstractArgumentValidator]] = None,
    optional_validators: Optional[Dict[str, AbstractArgumentValidator]] = None,
) -&gt; Callable:
    &#34;&#34;&#34;
    Decorator to validate Message type arguments for gRPC methods.

    Subfields can be separated by a `.`.

    E.g. `foo.bar` where bar is a property of the Message in foo.


    For lists the same notation can be used, for clarity `[]` can be added optionally. Both `foo.bar` and `foo[].bar`
    can be used, where bar is a property of the Message in the list foo.

        Parameters:
            has (Optional[List[str]]):
                Fields the Message should contain
            uuids (Optional[List[str]]):
                Fields to be validated for UUIDs
            non_default (Optional[List[str]]):
                Fields that should not have the default value
            non_empty (Optional[List[str]]):
                Fields that should not be empty
            optional_uuids (Optional[List[str]]):
                Fields that can be None or a valid UUID
            optional_non_empty (Optional[List[str]]):
                Fields that can be None or non-empty
            optional_non_default (Optional[List[str]]):
                Fields that can be None or non-default
            validators (Optional[Dict[str, AbstractArgumentValidator]]):
                Dict mapping field names to validators
            optional_validators (Optional[Dict[str, AbstractArgumentValidator]]):
                Dict mapping field names to validators, the fields can be None or validated using the specified
                validator

        Returns:
            decorating_function (func): the decorating function wrapping the gRPC method function
    &#34;&#34;&#34;
    if all(_none_or_empty(arg) for arg in locals().values()):
        raise ValueError(&#34;Should provide at least one field to validate&#34;)
    has_value = has or []

    optional_uuids_value = optional_uuids or []
    optional_non_empty_value = optional_non_empty or []
    optional_non_default_value = optional_non_default or []
    optional_validators_value: Dict[str, AbstractArgumentValidator] = optional_validators or dict()

    uuids_value = uuids or []
    non_empty_value = non_empty or []
    non_default_value = non_default or []
    validators_value = validators or dict()

    field_names = list(
        itertools.chain(
            has_value,
            uuids_value,
            optional_uuids_value,
            non_empty_value,
            optional_non_empty_value,
            non_default_value,
            optional_non_default_value,
            validators_value.keys(),
            optional_validators_value.keys(),
        )
    )
    validate_field_names(field_names)

    mandatory_fields = set(uuids_value + non_empty_value + non_default_value + list(validators_value.keys()))
    optional_fields = set(
        optional_uuids_value
        + optional_non_empty_value
        + optional_non_default_value
        + list(optional_validators_value.keys())
    )

    if mandatory_fields.intersection(optional_fields):
        raise ValueError(&#34;Overlap in mandatory and optional fields&#34;)

    def decorating_function(func):
        def validate_message(request: Message, context: grpc.ServicerContext, validation_context: ValidationContext):
            field_violations = []
            for field_name in field_names:
                field_validators: List[AbstractArgumentValidator] = []
                is_optional = (
                    field_name in optional_non_empty_value
                    or field_name in optional_uuids_value
                    or field_name in optional_non_default_value
                    or field_name in optional_validators_value
                )
                if field_name in uuids_value + optional_uuids_value:
                    field_validators.append(UUIDBytesValidator())
                if field_name in non_empty_value + optional_non_empty_value:
                    field_validators.append(NonEmptyValidator())
                if field_name in non_default_value + optional_non_default_value:
                    field_validators.append(NonDefaultValidator())
                if field_name in itertools.chain(validators_value.keys(), optional_validators_value.keys()):
                    validator = {**validators_value, **optional_validators_value}.get(field_name)
                    if validator is not None:
                        field_validators.append(validator)

                field_violations.extend(
                    _recurse_validate(
                        request,
                        name=field_name,
                        validators=field_validators,
                        is_optional=is_optional,
                        validation_context=validation_context,
                    )
                )
            if len(field_violations) &gt; 0:
                if ArgumentValidatorConfig.use_rich_grpc_errors():
                    rich_status = _create_rich_validation_error(field_violations)
                    context.abort_with_status(rpc_status.to_status(rich_status))
                else:
                    context.abort(
                        grpc.StatusCode.INVALID_ARGUMENT, &#34;, &#34;.join([e.reason for e in field_violations])[:1000]
                    )

        def validate_streaming(requests: Iterable[Message], context: grpc.ServicerContext):
            for i, req in enumerate(requests):
                validate_message(req, context, ValidationContext(is_streaming=True, streaming_message_index=i))
                yield req

        @functools.wraps(func)
        def validate_wrapper(self, request: Union[Message, Iterable[Message]], context: grpc.ServicerContext):
            if isinstance(request, Iterable):
                return func(self, validate_streaming(request, context), context)
            else:
                validate_message(request, context, ValidationContext(is_streaming=False, streaming_message_index=None))
                return func(self, request, context)

        return validate_wrapper

    return decorating_function


def _create_rich_validation_error(field_violations: List[_FieldViolation]):
    detail = any_pb2.Any()
    detail.Pack(
        error_details_pb2.BadRequest(
            field_violations=[
                error_details_pb2.BadRequest.FieldViolation(field=e.field_name, description=e.reason,)
                for e in field_violations
            ]
        )
    )
    return status_pb2.Status(
        code=code_pb2.INVALID_ARGUMENT,
        message=&#34;, &#34;.join([e.reason for e in field_violations])[:1000],
        details=[detail],
    )


def _recurse_validate(
    message: Message,
    name: str,
    validation_context: ValidationContext,
    validators: List[AbstractArgumentValidator],
    leading_parts_name: str = None,
    is_optional: bool = False,
) -&gt; List[_FieldViolation]:
    field_violations: List[_FieldViolation] = []
    field_name_raw, *remaining_fields = name.split(&#34;.&#34;)
    field_name = field_name_raw.rstrip(&#34;[]&#34;)

    remaining_fields = [f for f in remaining_fields if f != &#34;&#34;]

    if leading_parts_name is None and field_name == &#34;&#34;:
        field_value = message
        field_descriptor: FieldDescriptor = message.DESCRIPTOR  # type: ignore
        full_name = message.DESCRIPTOR.name
    else:
        field_descriptor = message.DESCRIPTOR.fields_by_name[field_name]

        full_name = field_name if leading_parts_name is None else f&#34;{leading_parts_name}.{field_name}&#34;
        if (
            field_descriptor.label != FieldDescriptor.LABEL_REPEATED
            and field_descriptor.type == FieldDescriptor.TYPE_MESSAGE
            and not message.HasField(field_name)
        ):
            if is_optional:
                return []
            return [_FieldViolation(field_name=full_name, reason=f&#34;must have &#39;{full_name}&#39;&#34;)]

        field_value = getattr(message, field_name)

    if remaining_fields:
        if field_descriptor.label == FieldDescriptor.LABEL_REPEATED:
            for i, elem in enumerate(field_value):  # type: ignore
                field_violations.extend(
                    _recurse_validate(
                        message=elem,
                        name=&#34;.&#34;.join(remaining_fields),
                        leading_parts_name=f&#34;{full_name}[{i}]&#34;,
                        validators=validators,
                        is_optional=is_optional,
                        validation_context=validation_context,
                    )
                )
        else:
            field_violations.extend(
                _recurse_validate(
                    message=field_value,
                    name=&#34;.&#34;.join(remaining_fields),
                    leading_parts_name=full_name,
                    validators=validators,
                    is_optional=is_optional,
                    validation_context=validation_context,
                )
            )
    else:
        for v in validators:
            if field_name_raw.endswith(&#34;[]&#34;) and field_descriptor.label == FieldDescriptor.LABEL_REPEATED:
                for i, field_value_elem in enumerate(field_value):  # type: ignore
                    full_field_name = f&#34;{full_name}[{i}]&#34;
                    validation_result = v.check(full_field_name, field_value_elem, field_descriptor, validation_context)
                    if not validation_result.valid:
                        field_violations.append(
                            _FieldViolation(
                                field_name=full_field_name,
                                reason=&#34;&#34;
                                if validation_result.invalid_reason is None
                                else validation_result.invalid_reason,
                            )
                        )
            else:
                validation_result = v.check(full_name, field_value, field_descriptor, validation_context)
                if not validation_result.valid:
                    field_violations.append(
                        _FieldViolation(
                            field_name=full_name,
                            reason=&#34;&#34; if validation_result.invalid_reason is None else validation_result.invalid_reason,
                        )
                    )
    return field_violations</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="grpc_argument_validator.validate_args_decorator.validate_args"><code class="name flex">
<span>def <span class="ident">validate_args</span></span>(<span>has: Union[List[str], NoneType] = None, uuids: Union[List[str], NoneType] = None, non_default: Union[List[str], NoneType] = None, non_empty: Union[List[str], NoneType] = None, optional_uuids: Union[List[str], NoneType] = None, optional_non_empty: Union[List[str], NoneType] = None, optional_non_default: Union[List[str], NoneType] = None, validators: Union[Dict[str, <a title="grpc_argument_validator.argument_validators.AbstractArgumentValidator" href="argument_validators.html#grpc_argument_validator.argument_validators.AbstractArgumentValidator">AbstractArgumentValidator</a>], NoneType] = None, optional_validators: Union[Dict[str, <a title="grpc_argument_validator.argument_validators.AbstractArgumentValidator" href="argument_validators.html#grpc_argument_validator.argument_validators.AbstractArgumentValidator">AbstractArgumentValidator</a>], NoneType] = None) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to validate Message type arguments for gRPC methods.</p>
<p>Subfields can be separated by a <code>.</code>.</p>
<p>E.g. <code>foo.bar</code> where bar is a property of the Message in foo.</p>
<p>For lists the same notation can be used, for clarity <code>[]</code> can be added optionally. Both <code>foo.bar</code> and <code>foo[].bar</code>
can be used, where bar is a property of the Message in the list foo.</p>
<pre><code>Parameters:
    has (Optional[List[str]]):
        Fields the Message should contain
    uuids (Optional[List[str]]):
        Fields to be validated for UUIDs
    non_default (Optional[List[str]]):
        Fields that should not have the default value
    non_empty (Optional[List[str]]):
        Fields that should not be empty
    optional_uuids (Optional[List[str]]):
        Fields that can be None or a valid UUID
    optional_non_empty (Optional[List[str]]):
        Fields that can be None or non-empty
    optional_non_default (Optional[List[str]]):
        Fields that can be None or non-default
    validators (Optional[Dict[str, AbstractArgumentValidator]]):
        Dict mapping field names to validators
    optional_validators (Optional[Dict[str, AbstractArgumentValidator]]):
        Dict mapping field names to validators, the fields can be None or validated using the specified
        validator

Returns:
    decorating_function (func): the decorating function wrapping the gRPC method function
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_args(
    has: Optional[List[str]] = None,
    uuids: Optional[List[str]] = None,
    non_default: Optional[List[str]] = None,
    non_empty: Optional[List[str]] = None,
    optional_uuids: Optional[List[str]] = None,
    optional_non_empty: Optional[List[str]] = None,
    optional_non_default: Optional[List[str]] = None,
    validators: Optional[Dict[str, AbstractArgumentValidator]] = None,
    optional_validators: Optional[Dict[str, AbstractArgumentValidator]] = None,
) -&gt; Callable:
    &#34;&#34;&#34;
    Decorator to validate Message type arguments for gRPC methods.

    Subfields can be separated by a `.`.

    E.g. `foo.bar` where bar is a property of the Message in foo.


    For lists the same notation can be used, for clarity `[]` can be added optionally. Both `foo.bar` and `foo[].bar`
    can be used, where bar is a property of the Message in the list foo.

        Parameters:
            has (Optional[List[str]]):
                Fields the Message should contain
            uuids (Optional[List[str]]):
                Fields to be validated for UUIDs
            non_default (Optional[List[str]]):
                Fields that should not have the default value
            non_empty (Optional[List[str]]):
                Fields that should not be empty
            optional_uuids (Optional[List[str]]):
                Fields that can be None or a valid UUID
            optional_non_empty (Optional[List[str]]):
                Fields that can be None or non-empty
            optional_non_default (Optional[List[str]]):
                Fields that can be None or non-default
            validators (Optional[Dict[str, AbstractArgumentValidator]]):
                Dict mapping field names to validators
            optional_validators (Optional[Dict[str, AbstractArgumentValidator]]):
                Dict mapping field names to validators, the fields can be None or validated using the specified
                validator

        Returns:
            decorating_function (func): the decorating function wrapping the gRPC method function
    &#34;&#34;&#34;
    if all(_none_or_empty(arg) for arg in locals().values()):
        raise ValueError(&#34;Should provide at least one field to validate&#34;)
    has_value = has or []

    optional_uuids_value = optional_uuids or []
    optional_non_empty_value = optional_non_empty or []
    optional_non_default_value = optional_non_default or []
    optional_validators_value: Dict[str, AbstractArgumentValidator] = optional_validators or dict()

    uuids_value = uuids or []
    non_empty_value = non_empty or []
    non_default_value = non_default or []
    validators_value = validators or dict()

    field_names = list(
        itertools.chain(
            has_value,
            uuids_value,
            optional_uuids_value,
            non_empty_value,
            optional_non_empty_value,
            non_default_value,
            optional_non_default_value,
            validators_value.keys(),
            optional_validators_value.keys(),
        )
    )
    validate_field_names(field_names)

    mandatory_fields = set(uuids_value + non_empty_value + non_default_value + list(validators_value.keys()))
    optional_fields = set(
        optional_uuids_value
        + optional_non_empty_value
        + optional_non_default_value
        + list(optional_validators_value.keys())
    )

    if mandatory_fields.intersection(optional_fields):
        raise ValueError(&#34;Overlap in mandatory and optional fields&#34;)

    def decorating_function(func):
        def validate_message(request: Message, context: grpc.ServicerContext, validation_context: ValidationContext):
            field_violations = []
            for field_name in field_names:
                field_validators: List[AbstractArgumentValidator] = []
                is_optional = (
                    field_name in optional_non_empty_value
                    or field_name in optional_uuids_value
                    or field_name in optional_non_default_value
                    or field_name in optional_validators_value
                )
                if field_name in uuids_value + optional_uuids_value:
                    field_validators.append(UUIDBytesValidator())
                if field_name in non_empty_value + optional_non_empty_value:
                    field_validators.append(NonEmptyValidator())
                if field_name in non_default_value + optional_non_default_value:
                    field_validators.append(NonDefaultValidator())
                if field_name in itertools.chain(validators_value.keys(), optional_validators_value.keys()):
                    validator = {**validators_value, **optional_validators_value}.get(field_name)
                    if validator is not None:
                        field_validators.append(validator)

                field_violations.extend(
                    _recurse_validate(
                        request,
                        name=field_name,
                        validators=field_validators,
                        is_optional=is_optional,
                        validation_context=validation_context,
                    )
                )
            if len(field_violations) &gt; 0:
                if ArgumentValidatorConfig.use_rich_grpc_errors():
                    rich_status = _create_rich_validation_error(field_violations)
                    context.abort_with_status(rpc_status.to_status(rich_status))
                else:
                    context.abort(
                        grpc.StatusCode.INVALID_ARGUMENT, &#34;, &#34;.join([e.reason for e in field_violations])[:1000]
                    )

        def validate_streaming(requests: Iterable[Message], context: grpc.ServicerContext):
            for i, req in enumerate(requests):
                validate_message(req, context, ValidationContext(is_streaming=True, streaming_message_index=i))
                yield req

        @functools.wraps(func)
        def validate_wrapper(self, request: Union[Message, Iterable[Message]], context: grpc.ServicerContext):
            if isinstance(request, Iterable):
                return func(self, validate_streaming(request, context), context)
            else:
                validate_message(request, context, ValidationContext(is_streaming=False, streaming_message_index=None))
                return func(self, request, context)

        return validate_wrapper

    return decorating_function</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="grpc_argument_validator" href="index.html">grpc_argument_validator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="grpc_argument_validator.validate_args_decorator.validate_args" href="#grpc_argument_validator.validate_args_decorator.validate_args">validate_args</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
